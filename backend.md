# Тест на вакансию Backend-разработчик Mind&Machine

В рамках данного теста необходимо ответить на вопросы связанные с работой Django, celery и других типовых инструментов.

Выполнил: Александр Неварко

Контакт: telegram/whatsapp +79252032742


## Блок №1: гуру Django

Предположим, что разрабатываем общедоступный сайт для магазина одежды (например сайт для adidas). Для этого в системе должны быть модели:

- Item -- товар магазина (из одежды), соотвественно есть цена, названия, для какого пола.
- User -- пользователь, клиент с возможностью захода в личный кабинет:


```python

import datetime

from django.db import models
from django.contrib.auth.models import AbstractUser as DjangoAbstractUser


class Item(models.Model):
    dttm_created = models.DateTimeField(default=datetime.datetime.now)
    dttm_deleted = models.DateTimeField()

    price = models.FloatField()


class User(DjangoAbstractUser):
    dttm_created = models.DateTimeField(default=datetime.datetime.now)
    dttm_deleted = models.DateTimeField()

    SEX_FEMALE = 'F'
    SEX_MALE = 'M'
    SEX_CHOICES = (
        (SEX_FEMALE, 'Female',),
        (SEX_MALE, 'Male',),
    )

    sex = models.CharField(max_length=1,  choices=SEX_CHOICES)
    bought_items = models.ManyToManyField(Item)

```


Из ТЗ виртуального заказчика необходимо, чтобы в системе было видно, что и когда клиент магазина купил.

-----

##### Вопрос №1: Соответствует ли база требованиям? Как стоит реализовать?

С данной схемой БД получится лишь узнать какие товары купиль клиент, но не когда, так как для этого нет соотетствующего поля.
Для реализации этой функции я бы создал вспомогательную таблицу, в которой было бы три поля: id клиента, id товара и время попкупки. Данная таблица имела бы связи один-ко-многим со стороны таблицы клиентов и со стороны таблицы товаров. Это стандартный ход для разведения связи много-ко-многим.
Так же, в таблице товаров нет поля для какого-то описания товара.

-----

##### Вопрос №2: есть ли в модели User лишние поля?

Поле с предпочтениями в одежде не имеют большого смысла, так как "пола" у одежды, судя по таблице товаров тоже нет.
Так же, поле bought_items теперь будет ссылаться на записи во вспомогательной таблице, в случае реализации по моему сценарию.

-----


##### Вопрос №3: По ТЗ необходимо написать запрос, который возвращает количество вещей и их стоимость для каждого клиента, которые они купили. список клиентов (id) передается в запросе:

```python

import datetime
from adidas.models import User, Item


def view(request):
    user_ids = request.GET.getlist('ids')
    return_data = User.objects.filter(id__in = ids).iterator()
    response = {}
    for client in return_data:
        response[client.id] = (client.bought_items.count(), client.boght_items.aggregate(Sum('price')))

    return response

```

-----

##### Вопрос №4: По ТЗ необходимо написать запрос, который возвращает список товаров магазинов, которые удовлевторяют следующим фильтрам: фильтр по полу клиентов, которые покупали товар; фильтр по цене. Если указаны оба фильтра, то выводятся только те товары, которые удовлетворяют обоим фильтрам. При этом, вместе с атрибутами модели Item надо еще вернуть  количество клиентов, которые купили этот товар и зарегистрированы  в системе до 2019.05.01 (если еще пол указан в фильтре, то соотвественно у считаемых клиентов должен быть этот пол):

```python

import datetime
(место для кода)

from django import forms


class ViewForm(forms.Form):
    price = forms.FloatField(required=False)
    sex = forms.CharField(max_length=1, required=False)



def view(request):
    edge_date = datetime.date(2019, 5, 1)

    form = ViewForm(request.GET)
    if form:
        return_data = Item.objects. (место для кода)


    ...

    return response

```

-----

##### Вопрос №5: В бд необходимо добавить новую модель Seller (продавец магазина). Причем каждый клиент должен быть привязан к Seller (клиент сформировал ТЗ  на обновление после 3 месяцев функционирования сайта (есть данные в бд)):

```python

class User(DjangoAbstractUser):
    dttm_created = models.DateTimeField(default=datetime.datetime.now)
    dttm_deleted = models.DateTimeField()

    SEX_FEMALE = 'F'
    SEX_MALE = 'M'
    SEX_CHOICES = (
        (SEX_FEMALE, 'Female',),
        (SEX_MALE, 'Male',),
    )

    sex = models.CharField(max_length=1,  choices=SEX_CHOICES)
    bought_items = models.ManyToManyField(Item)

    seller = models.ForeignKey('Seller', on_delete=models.PROTECT)
    
class Seller(models.Model):
    name = models.CharField(max_length=100)

```

##### Что необходимо сделать и как, чтобы реализовать обновление?

Вероятно, привязка клиента к продавцу будет осуществляться с первой покупкой, так что необходимо добавить установление связи клиент-продавец при записи о первой покупке.
Так же необходимо привязать уже существующих активных пользователей (которые совершили хотя бы одну покупку) к продавцам. По какому принципу это сделать - решать заказчику, если это, например, влияет на зарплаты. Можно поставить некоторые заглушки, например, сделать запись "старого продавца" в таблице и привязать к нему всех пользователей, которые были в БД до обновления. 

-----


## Блок №2: мастер на все руки

##### Вопрос №6: Как развернуть django на боевом сервере? что нужно/можно использовать?

Необходимо установить все нужные пакеты (python, pip, django, git, используемую базу данных и т.д.). Далее необходимо создать БД, совершить миграции (залить схему БД из проекта django), и зпустить сервре. По-хорошему ещё нужно установить nginx и gunicorn для распределения нагрузки на сервер, но, если честно, конкретно этого я не делал.
Так же, все эти действия можно не совершать, если пользоваться Docker, он деплоит всё сам.

##### Вопрос №7: Redis или RabbitMQ для Celery? Почему?

Не работал с данными инструменатми.


##### Вопрос №8: Какие подходы к реализации иерархии в бд есть?

Реляционный и не реляционный.
Не реляционный подход - это запись всех данных в одну таблицу. Хорошо подходит для неструктурированных данных, просто как хранилище.
Реляционный подход предполагает проектирование БД с архитектурой "сущность-связь". Данная иерархия более оптимальна для сложных структур данных и взаимосвязей между ними, помогает соптимизировать поиск и выкачку данных из БД.


##### Вопрос №9: Реализуем проект для клиента, по ТЗ необходимо, чтобы система выдерживала 1 млн запросов в минуту (не обязательно на чтение). Какую свободную реляционную СУБД стоит использовать?

MySQL, так как она является оптимальной по скорости работы.

